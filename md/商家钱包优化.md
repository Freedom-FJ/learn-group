## 前言
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701070650974-e656652a-3d92-4358-8e3a-b318a29ce894.jpeg)
> 在我们的商家钱包中，主要有 `安全`、`规范`、`性能`等缺陷，使得工程有多个隐患，不利于项目的持续迭代更新以及多人员的开发。

本文就围绕以上三个核心目标，开始整个工程的改造。

## 工程规范化
解决方案：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701864763689-58833cb4-4837-46a0-bdab-9f709b6ae4da.jpeg)
### 删除无用代码
运行 `umi deadcode` 的无用文件检查命令，其会按照如下步检查文件：

1. 初始会读取文件匹配所有符合 `exclude 正则`的文件目录，整理出所有 `exclude file`；
2. 调用 `madge` 从入口文件出发并传入 tsconfig信息，分析所有文件的依赖关系，生成`madge tree`依赖树；
3. 最后用`fs` 所有目录文件依次执行 filter 方法去除 `exclude file` 和 `madge tree`各自包含的文件，剩下的就是deadcode了。

packages/preset-umi/src/commands/deadcode.ts
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701077318545-9bb008f0-4f0d-4439-aec7-20a2f2a39034.jpeg)
运行结果：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700187575378-2980ab04-bebe-403e-a19a-7e6ff4a3c204.png#clientId=u4b2735bd-1a6d-4&from=paste&height=172&id=u23254b0f&originHeight=343&originWidth=1173&originalType=binary&ratio=2&rotation=0&showTitle=false&size=123079&status=done&style=none&taskId=ub8074785-419c-4154-bc5a-3c13f91cf27&title=&width=586.5)
书写一个简单的统计代码行数的node脚本,运用fs读取src主文件夹内的文件，递归检索行数。
`count-line.js`：
```typescript
const fs = require('fs');

let totalLines = 0;
let filesNum = 0
function countLinesInDirectory(directory) {

  const files = fs.readdirSync(directory);

  files.forEach((file) => {
    const filePath = `${directory}/${file}`;
    const stats = fs.statSync(filePath);

    if (stats.isFile()) {
      const fileContent = fs.readFileSync(filePath, 'utf-8');
      const lines = fileContent.split('\n').length;
      totalLines += lines;
      filesNum ++
    } else if (stats.isDirectory()) countLinesInDirectory(filePath);
  });
}

const directoryPath = './src';
countLinesInDirectory(directoryPath);
console.log(`Total lines of code: ${totalLines}，filesNum: ${filesNum}`);
```
运行 `node count-line.js` ,总共我们通过命令的检索和自己的排查 删除69个文件，9632行代码。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700139918189-879a2043-182a-469e-a5d1-d22c8a855097.png#clientId=u5af6b677-48c1-4&from=paste&height=31&id=ucd7deb70&originHeight=55&originWidth=519&originalType=binary&ratio=2&rotation=0&showTitle=false&size=12046&status=done&style=none&taskId=ufac4cd4c-2da8-4d32-976e-7d6d3907e9c&title=&width=295.5)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700139966440-e61c40eb-9817-4687-aa13-a608f567468f.png#clientId=u5af6b677-48c1-4&from=paste&height=29&id=uc061cdb8&originHeight=37&originWidth=497&originalType=binary&ratio=2&rotation=0&showTitle=false&size=8818&status=done&style=none&taskId=ua16641f1-dbb7-4ad7-a46e-7fafc0f2b81&title=&width=388)
整体src主包文件减少 **1.9mb** => **1.6mb**， 缩小** 15.7%**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700124377190-04b91cd8-d8cf-4489-9018-6af153725a53.png#clientId=u1bbf33eb-3099-4&from=paste&height=205&id=ufaf71523&originHeight=656&originWidth=1150&originalType=binary&ratio=2&rotation=0&showTitle=false&size=446737&status=done&style=none&taskId=u2dcc1b77-dc1b-4b5f-b16e-deae4977a62&title=&width=360)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700124407691-7b5c24bf-b94c-4bbc-ab05-9a9b5a4a43df.png#clientId=u5af6b677-48c1-4&from=paste&height=208&id=u282f99da&originHeight=670&originWidth=1162&originalType=binary&ratio=2&rotation=0&showTitle=false&size=468202&status=done&style=none&taskId=ua7dce902-c670-4f65-836c-fa1a6486c72&title=&width=361)

### 组建抽离

| 组建名称 | 复用率 | 组建图片 |
| --- | --- | --- |
| password-form/密码校验表单 | 8/8 100% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700536590609-58155e81-2e9e-4277-99a1-aa5d15b13944.png#clientId=ucc9ea1e1-def2-4&from=paste&height=115&id=u165b8d3a&originHeight=230&originWidth=531&originalType=binary&ratio=2&rotation=0&showTitle=false&size=20343&status=done&style=none&taskId=u541f2330-1948-48e3-b514-7fb27b76adf&title=&width=265.5) |
| number-picker/数字输入框 | 5/5 100% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700536607702-be5472c4-86b6-4c3d-b60a-b2ef8898468e.png#clientId=ucc9ea1e1-def2-4&from=paste&height=48&id=u10f5a1c1&originHeight=96&originWidth=346&originalType=binary&ratio=2&rotation=0&showTitle=false&size=6981&status=done&style=none&taskId=ub46b1c2c-7e4a-4443-89e7-3be1dd60523&title=&width=173) |
| verify-pass/密码不触发保存输入框核身 | 6/6 100% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700537355372-44be1d40-154c-48f6-8ab3-82cf587f555b.png#clientId=ucc9ea1e1-def2-4&from=paste&height=58&id=u9e38b056&originHeight=116&originWidth=536&originalType=binary&ratio=2&rotation=0&showTitle=false&size=8228&status=done&style=none&taskId=u234fbbae-734a-47b5-a40f-86f834d040a&title=&width=268) |
| result-box/结果组建 | 21/21 100% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700537131348-01858999-b15f-4517-9e87-d01ea9aa2028.png#clientId=ucc9ea1e1-def2-4&from=paste&height=147&id=u61a72772&originHeight=293&originWidth=452&originalType=binary&ratio=2&rotation=0&showTitle=false&size=13366&status=done&style=none&taskId=u17d1e5af-fe1d-4065-89c2-11c4e7c0311&title=&width=226) |
| chc-mod-tab/tab页切换组建 | 9/9 100% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700721894420-f50bff22-5e25-445a-b190-13264f13dbc7.png#clientId=u95c0f3e4-565a-4&from=paste&height=231&id=u83d8fd22&originHeight=461&originWidth=664&originalType=binary&ratio=2&rotation=0&showTitle=false&size=29408&status=done&style=none&taskId=ufa04d0c8-4be6-4695-86cb-ea861054428&title=&width=332) |
| text-help-balloon/便捷提示组建 | 26/28 92.9% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700537054359-ff41f6ed-2cd6-488d-9cb7-b85112569333.png#clientId=ucc9ea1e1-def2-4&from=paste&height=50&id=u6b707535&originHeight=100&originWidth=281&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10516&status=done&style=none&taskId=uff1c6574-efc7-41cf-aab2-c2a69874ee0&title=&width=140.5) |
| skeleton-page/ 骨架屏 | 8/9 88.9% | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700537020332-b7f2675b-8658-41ad-b356-3519ee1deb46.png#clientId=ucc9ea1e1-def2-4&from=paste&height=365&id=u0138c121&originHeight=729&originWidth=2193&originalType=binary&ratio=2&rotation=0&showTitle=false&size=31688&status=done&style=none&taskId=u5abc7978-9e39-4b20-81f4-2e1650f62ab&title=&width=1096.5) |
| step-page/流程组建 | 1/12 8.3%（复用率低原因：原逻辑较为复杂，先不建议修改） | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700536664614-8f6fdba6-6267-4ff1-a01c-8d26ce3027bd.png#clientId=ucc9ea1e1-def2-4&from=paste&height=371&id=u86a89d11&originHeight=742&originWidth=2202&originalType=binary&ratio=2&rotation=0&showTitle=false&size=81904&status=done&style=none&taskId=ud1156978-687a-4a36-b365-6317b2bd6be&title=&width=1101) |

### Eslint修复
通过eslint修复项目工程是老生常谈的问题，我对于整个项目配置了更加严格的eslint语法检查逻辑
配置vscode settings文件,实现自动化的语法修复并且错误提示。
```json

"[typescriptreact]": {
  "editor.defaultFormatter": "rvest.vs-code-prettier-eslint"
},
"editor.codeActionsOnSave": {
  "source.fixAll": true,
  // "source.organizeImports": true, // 自动组织import顺序
  "source.fixAll.eslint": true
},
"eslint.validate": [
  "javascript",
  "javascriptreact",
  "typescript",
  "typescriptreact",
],
/* prettier配置遵循eslint规则 */
"prettier.jsxSingleQuote": true,
"prettier.semi": false,
```
配置eslint.js, 实现react的tsx语法，ts类型检查，并且对基础的引入资源格式也进行格式化校验
```javascript
module.exports = {
  extends: require.resolve('@umijs/lint/dist/config/eslint'),
  rules: {
   '@typescript-eslint/no-unused-expressions': 'off',
    "@typescript-eslint/no-use-before-define": "off",
    "no-param-reassign": "off"
  //  "no-use-before-define": "off",
  //   "no-console": "off",
  //   "no-bitwise": "off",
  //   "no-shadow": "off",
  //   "@typescript-eslint/no-shadow": "off",
  //   "radix": "off",
  //   "@typescript-eslint/no-explicit-any": "off",
  //   "react/react-in-jsx-scope": "off",
  //   "react/no-unused-prop-types": "off",
  //   "object-curly-spacing": "off",
  //   "@typescript-eslint/indent": "off",
  }
};

```
可以看到我们原先未使用的变量直接变成了`error`，这样不修复此问题开发人员将无法进行commit提交。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701064894903-e63981f0-e779-4844-85ad-e0903c1c4ca6.png#clientId=uc120af86-bac2-4&from=paste&height=162&id=u1ea1c1dd&originHeight=324&originWidth=1008&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79740&status=done&style=none&taskId=u15ee1824-1c69-432a-a444-65d63b69a1c&title=&width=504)
配置packages.json
```json
"eslint": "eslint \"src/**/*.{ts,tsx}\"",
"eslint:fix": "eslint --fix \"src/**/*.{ts,tsx}\"",
```
并配置 staged 提交拦截功能，拦截commit提交，进行eslint语法检查，通过才可以提交，用于约束开发人员的代码书写。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700722480677-c69b48af-7ab8-48b3-a54d-aa4aa4535932.png#clientId=u218563fc-4a79-4&from=paste&height=208&id=uac4104b3&originHeight=416&originWidth=592&originalType=binary&ratio=2&rotation=0&showTitle=false&size=66661&status=done&style=none&taskId=u61b1da94-8d32-4e0f-9dae-49230c53d1b&title=&width=296)
执行修复代码配合手动修复
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701834173603-eb413830-2543-4975-b897-2144e1664ee1.png#clientId=u164271ac-516d-4&from=paste&height=204&id=u3bb16fcf&originHeight=408&originWidth=1142&originalType=binary&ratio=2&rotation=0&showTitle=false&size=312403&status=done&style=none&taskId=ub86e5eea-3c76-4273-970c-eaf92cb02ee&title=&width=571)
结果：共计修复`609`个问题，其中`609`个 errors 级错误和`0`个warning 级别错误
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700631701788-fbc24589-04ea-46f2-9468-2c5ce8072008.png#clientId=u0af37576-5a08-4&from=paste&height=59&id=u8c7f0cb7&originHeight=96&originWidth=677&originalType=binary&ratio=2&rotation=0&showTitle=false&size=15271&status=done&style=none&taskId=u0af58f88-c502-44cf-91ec-2c6a968c898&title=&width=413.5)
### Stylelint修复
css的修复以及检查当然需要stylelint来实现，配置更加严格的stylelint方案
安装插件：
```bash
npm i stylelint stylelint-config-standard stylelint-order stylelint-config-rational-order stylelint-scss -D

```
配置规范：严格规范stylelint书写，包括定义格式，属性顺序，嵌套深度（有利于性能优化），未知标签等问题。
```json
module.exports = {
  "extends": [
    "stylelint-config-standard",
    "stylelint-config-rational-order"
  ],
  "rules": {
    "at-rule-no-unknown": null,
    "no-missing-end-of-source-newline": null,
    "no-descending-specificity": null,
    "indentation": 2,
    "scss/at-rule-no-unknown": true,
    "selector-max-compound-selectors": 4,
    "max-nesting-depth": 4,
    "selector-pseudo-class-no-unknown": [
      true,
      {
        "ignorePseudoClasses": ["global"]
      }
    ],
    'property-no-unknown': [
      true,
      {
        'ignoreProperties': [
        'box-orient',
      'container-type',
      'container-name'
    ]
  },
  ]
},
  "plugins": [
    "stylelint-scss"
  ]
}
```
配置vscode settings文件，实现保存自动修复：
```json
// stylelint配置
"stylelint.enable": true,
"css.validate": false,
"less.validate": false,
"scss.validate": false,
"[scss]": {
  "editor.formatOnSave": true
},
"stylelint.validate": [
  "css",
  "less",
  "postcss",
  "scss",
  "sass"
],
```
配置husky commit 提交stylelint校验css相关语法，做到规范代码，和拦截提交的作用。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700620776580-4ddeb8bd-bcf5-4a95-955d-eb1ea7379e87.png#clientId=u548fbb27-2946-4&from=paste&height=185&id=u6bdba7fc&originHeight=282&originWidth=511&originalType=binary&ratio=2&rotation=0&showTitle=false&size=27575&status=done&style=none&taskId=ud6252246-e7d0-4b60-96fc-830fef3dc9e&title=&width=335.5)
配置package.json 文件 `stylelint`命令，运行修复。
```json
"stylelint": "stylelint \"src/**/*.{css,less,scss}\" --fix",
```
共计修复 `418` 个前端样式问题, 修改 `67` 个样式文件。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700620133630-b7309b14-297e-498c-a9b3-8b2cbb1b05f7.png#clientId=u548fbb27-2946-4&from=paste&height=433&id=u9a3cc676&originHeight=865&originWidth=1043&originalType=binary&ratio=2&rotation=0&showTitle=false&size=262109&status=done&style=none&taskId=uf7afb5d5-ff02-4089-9b92-2b73da4b1a1&title=&width=521.5)
###  目录结构调整
在我们的项目目录中，发现**layout目录**下有非常多的文件夹，而通常layout目录下为全局布局，默认会在所有路由下生效，所以正常我们不应该将页面pages的内容放在layout内，且有很多pages重复书写了多套header样式，我们将目录结构调整，把layout内容整理，只留下**登陆后布局**和**未登录布局**，优化后目录结构如下：
优化前：					优化后：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701053662617-3028417f-8b83-42a4-9cd3-b2bc0d727501.png#clientId=u0ad0fa5e-51f5-4&from=paste&height=212&id=u8f55803e&originHeight=423&originWidth=416&originalType=binary&ratio=2&rotation=0&showTitle=false&size=30258&status=done&style=none&taskId=u0e449e3f-1e55-4f06-be11-37044b69b88&title=&width=208)	  ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701053604360-7381d4eb-b3ab-4cbb-b80c-e167b1962c79.png#clientId=u0ad0fa5e-51f5-4&from=paste&height=213&id=u1ce6111c&originHeight=425&originWidth=453&originalType=binary&ratio=2&rotation=0&showTitle=false&size=31230&status=done&style=none&taskId=ub66bdaca-9a01-4bda-90bf-e671b633bde&title=&width=226.5)
### service层
优化前：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701078552783-5cf9758a-226a-4acd-88fa-66feb4c4f70f.jpeg)
优化后：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701071557010-77000e1d-8c75-4712-bc59-be6bc9e5e25d.jpeg)
目录结构：
```javascript
|  ├── services							   	// 服务接口
|  |  └── api-hook							// 接口hook
|  |  |  └── 模块1							  // 模块1 比如资金管理
|  |  |  |  └── index.ts			  // 接口hook
|  |  |  |  └── types.d.ts			// 类型命名空间
|  |  |  └── 模块2				        // 接口hook
|  |  |  └── ...				        // 接口hook
|  |  └── apis.ts								// 单个api文件
```
模块1/index.ts:
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701072109998-e7735488-e6d2-4978-8892-3778d0afc136.png#clientId=udf5b353f-2a7d-4&from=paste&height=189&id=uc809094b&originHeight=242&originWidth=642&originalType=binary&ratio=2&rotation=0&showTitle=false&size=61800&status=done&style=none&taskId=ua98ce147-ea29-488c-bc78-58adda78e9e&title=&width=501)
模块1/index.d.ts:
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701072170130-068edcdb-b184-4da0-ac6f-7d8e7efd3c1b.png#clientId=udf5b353f-2a7d-4&from=paste&height=398&id=u24de6621&originHeight=795&originWidth=666&originalType=binary&ratio=2&rotation=0&showTitle=false&size=118684&status=done&style=none&taskId=u183904e0-cc6c-4cfd-a9d1-91214e1d765&title=&width=333)
### def门神
我们可以在def的代码检查设置内添加对应的代码检查插件，我们加入了 资源大小检查，语法检查，代码重复率检查，eslint代码复杂度检查。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701164491864-09ba7694-0232-439e-adc0-47a110e0b380.png#clientId=ud5dd5c02-01b4-4&from=paste&height=731&id=u1194444b&originHeight=1462&originWidth=3548&originalType=binary&ratio=2&rotation=0&showTitle=false&size=3505930&status=done&style=none&taskId=u8a26f201-2eaf-4f7f-ab81-09c7e09ae7a&title=&width=1774)
这样在我们每一次的构建过程中就可以起到最后兜底检查的作用：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701164456629-b0c2c8ba-1801-41ee-af33-bcd41b9552b3.png#clientId=ud5dd5c02-01b4-4&from=paste&height=738&id=u6944410a&originHeight=1476&originWidth=2826&originalType=binary&ratio=2&rotation=0&showTitle=false&size=609598&status=done&style=none&taskId=u2bb0fa01-adb7-422c-bae5-7df905bba26&title=&width=1413)
### 监控接入
在 [AEM](https://sg.aem.alibaba-inc.com/project/aepay-merchant-wallet/page/board) 新建应用，按照步骤创建，并在我们的diamond内配置我们项目html文件内加入如下埋点逻辑：
```
<script src="https://g.alicdn.com/aes/??tracker/3.0.5/index.js,tracker-plugin-pv/3.0.2/index.js,tracker-plugin-event/3.0.0/index.js,tracker-plugin-jserror/3.0.3/index.js,tracker-plugin-api/3.0.7/index.js,tracker-plugin-resourceError/3.0.2/index.js,tracker-plugin-perf/3.0.7/index.js,tracker-plugin-eventTiming/3.0.0/index.js,tracker-plugin-longtask/3.0.1/index.js,tracker-plugin-blank/3.0.1/index.js,tracker-plugin-animFluency/3.0.0/index.js,tracker-plugin-emogine/3.0.5/index.js,tracker-plugin-autolog/3.0.3/index.js,tracker-plugin-survey/3.0.10/index.js"></script>
<script>
  const aes = new AES({
    pid: "aepay-merchant-wallet",
    user_type: "13",
    env: 'pre',
  });
  aes.use([AESPluginPV,AESPluginEvent,AESPluginJSError,AESPluginAPI,AESPluginResourceError,AESPluginPerf,AESPluginEventTiming,AESPluginLongTask,AESPluginBlank,AESPluginAnimFluency,AESPluginEmogine,AESPluginAutolog,AESPluginSurvey]);
  window.aes = aes;
</script>
```
其可以对我们项目进行诸如：流量、满意度分析、流程性分析、热力分析、稳定性分析等等。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701681628410-d61cd5d8-d0a5-4752-9bd4-8c06b36afee7.png#clientId=u456a30c2-2b53-4&from=paste&height=857&id=udb08c10e&originHeight=1714&originWidth=2994&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1031264&status=done&style=none&taskId=u5c86fd2e-a9e0-4a3d-84e1-4e8c1e23530&title=&width=1497)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701681510804-a43c55cd-ee2d-4179-8f48-feacb6ac40f3.png#clientId=u456a30c2-2b53-4&from=paste&height=929&id=u16294189&originHeight=1858&originWidth=3574&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1239414&status=done&style=none&taskId=u1f4abbac-755b-4064-bffd-62dfbcb508f&title=&width=1787)

**接入自定义事件：**
我们需要对我们美杜莎的显示增加一个自定义事件，用于提醒我们美杜莎key值未解析报错：
保存sendEvent事件
```javascript
<script>
  const aes = new AES({
    pid: "aepay-merchant-wallet",
    user_type: "13",
    env: 'pre',
  });
  const pluginArr = aes.use([AESPluginPV,AESPluginEvent,AESPluginJSError,AESPluginAPI,AESPluginResourceError,AESPluginPerf,AESPluginEventTiming,AESPluginLongTask,AESPluginBlank,AESPluginAnimFluency,AESPluginEmogine,AESPluginAutolog,AESPluginSurvey]);
  window.sendAesEvent = pluginArr[1];
  window.aes = aes;
</script>
```
书写发送事件：
```javascript
const unkownKey = 'unkown-i18n'; // 未知美杜莎事件的标识
const sendAesEvent = window.sendAesEvent;

// i18nFactory
const soreString = stringStore[mdsKey];
if (!soreString && sendAesEvent) // 当美杜莎key值在全局文件中找不到时发送自定义事件
  sendAesEvent(unkownKey, {
    et: 'EXP',
    c1: `mdsKey=${mdsKey}`,
  });
```
验证：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701774549473-b4c6e43b-bd50-490f-b6d3-7e013408a036.png#clientId=u47b42e10-3828-4&from=paste&height=504&id=u4640152e&originHeight=1008&originWidth=3492&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1216723&status=done&style=none&taskId=u4fa039f0-bd00-4bb5-ad2e-54b050478e6&title=&width=1746)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1702018637138-22ef4f11-cd26-42e8-9116-80302321449e.png#clientId=u982917dd-8a2f-4&from=paste&height=183&id=u70389242&originHeight=366&originWidth=1424&originalType=binary&ratio=2&rotation=0&showTitle=false&size=314596&status=done&style=none&taskId=u529aa218-a38d-434d-bcac-78dd95cec07&title=&width=712)

## 性能检测
对于用户体验而言 速度至关重要一项[消费者研究](https://www.ericsson.com/en/press-releases/2016/2/streaming-delays-mentally-taxing-for-smartphone-users-ericsson-mobility-report)表明，对网页加载速度延迟的压力反应类似于观看恐怖电影或解决数学问题，并且比在零售店排队等候的压力更大。
研究表明，性能不佳可能会对业务成效产生_负面影响_。例如，[BBC 发现其网站的加载速度每增加一秒，就会额外损失 10% 的用户](https://www.creativebloq.com/features/how-the-bbc-builds-websites-that-scale)。
如果您注重留住用户，则应关注性能！
方案设计：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1702383460095-df31121f-2f6d-47da-ba6d-5b0ae07ede5b.jpeg)
### 本地模拟启动项目
由于umi4版本没有了serve指令用于启动本地打包文件
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701834504175-e759c16f-405d-4502-8be6-e5ccafaf99c5.png#clientId=u00525b39-300b-4&from=paste&height=205&id=u584df31b&originHeight=409&originWidth=657&originalType=binary&ratio=2&rotation=0&showTitle=false&size=182699&status=done&style=none&taskId=u936222df-f7ca-409b-8f1b-a15b0f5a8e2&title=&width=328.5)
所以启动本地服务器, 我们可以安装 **http-server**, 修改打包build产物内的 **umi.js umi.css** 的引入路径为** http:127.0.0.1:9001**。进入build目录，启动本地服务为 **9001**且 **--cors** 允许跨域, --gzip开启服务端压缩。
```typescript
tnpm i http-server
cd build
http-server -p 9001 --cors --gzip
```
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700281868207-01f7f6b8-7346-4acf-b73d-efae7d04726b.png#clientId=u7048c44a-13d0-4&from=paste&height=934&id=u5de912a8&originHeight=1868&originWidth=3584&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1152880&status=done&style=none&taskId=u307dd9df-0871-489f-95dc-7e9d089f8ea&title=&width=1792)

### 性能**指标分析**

1. **认识工具**

![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701242198000-ff987e15-82dd-476f-9992-e7a08beefca1.jpeg)

2. **指标衡量**

首先就是衡量我们性能最为关键的，性能指标， 其可以很快的对我们整个项目的运行情况进行判断，确定是否优异。

| 名称 | 含义 | 平均指标 |
| --- | --- | --- |
| #### FP _（First Paint）_
 | **指页面的首次渲染的时间点**。在完成首次渲染之前，用户看到的都是 **没有任何内容的白色页面**，也就是我们常说的 **白屏时间**。
_FP_ 可以**反映页面加载的整体速度**。 |  |
| #### FCP _（First Contentful Paint）_
 | **指页面的首个内容绘制时间**，即浏览器在页面上绘制出第一块有实际内容的区域（如文本、图像等）的时间点。
_FCP_ 反映了用户可以看到**有意义的内容的时间**。 | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701778471640-02b0b6c3-f9ba-4e5b-be58-90a6c2c6ead0.png#clientId=ua9d60b19-6828-4&from=paste&height=160&id=u62f5d33d&originHeight=320&originWidth=854&originalType=binary&ratio=2&rotation=0&showTitle=false&size=160310&status=done&style=none&taskId=u8409dab3-fc08-4f80-8358-4e7f119bdce&title=&width=427) |
| #### DCL _（DOM Content Loaded）_
 | **指当 HTML 文档被完全加载和解析后，DOM 树构建完成并且所有关联资源（如样式表、脚本等）已经下载完成，触发 DOMContentLoaded 事件的时间点**。
_DCL_ 反映了页面的可交互性，表示**页面已经准备好响应用户的操作**。 |  |
| #### L _（Load）_
 | **页面完全加载完成的时间点**。包括所有资源（如图片、样式表、脚本等）都已下载完成，并且相关的 DOM、CSSOM 和 JavaScript 都已经处理完成。
_L_ 反映了整个页面加载的时间。 |  |
| #### LCP _（Largest Contentful Paint）_
 | 指页面上**最大的一个可见元素（如图片、文本等）绘制完成的时间点**。
_LCP_ 是衡量页面加载速度的重要指标，它反映了页面主要内容的加载完成时间。 | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701778339211-822e70a7-f386-4d0b-beb7-b3e55ba07356.png#clientId=ua9d60b19-6828-4&from=paste&height=342&id=ub9cb6f41&originHeight=684&originWidth=1830&originalType=binary&ratio=2&rotation=0&showTitle=false&size=493887&status=done&style=none&taskId=u77610cda-076d-4a93-a363-73b1c4db701&title=&width=915) |

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701238394935-2b6afdb4-325c-4c99-975c-286ce557969d.png#clientId=u62c239cf-e49d-4&from=paste&height=508&id=u7537de56&originHeight=1015&originWidth=1795&originalType=binary&ratio=2&rotation=0&showTitle=false&size=202581&status=done&style=none&taskId=u15592d95-60a3-48ac-a880-34605dae379&title=&width=897.5)

| 指标名称 | 网速正常 | 快速3g |
| --- | --- | --- |
| DCL | 797.25ms  | 10.35s |
| FP | 804.62ms | 4.48s |
| FCP | 804.62ms | 19.04s |
| L | 1.73s | 20.44s |
| LCP  | 3.08s | 22.79s |

### network和task分析：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701087470524-8a1cdd85-3fa2-4053-b665-b4705e3b6756.png#clientId=u5e23611d-d817-4&from=paste&height=241&id=uf589c1da&originHeight=482&originWidth=3014&originalType=binary&ratio=2&rotation=0&showTitle=false&size=359758&status=done&style=none&taskId=ucff0bc3c-9779-4a43-9aa1-3d01d2d4bfe&title=&width=1507)
**上侧侧的黄色瀑布是network请求的内容区域，其条区域的内容对应请求的如下阶段：**
![a0fdf49b720e46ddb1325cb443dbab5f~tplv-k3u1fbpfcp-jj-mark_3024_0_0_0_q75.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701066662327-4a0df3e4-9324-49c0-8997-1c5da449c802.png#clientId=ued861c13-cec2-4&from=ui&id=J8pYC&originHeight=142&originWidth=1242&originalType=binary&ratio=2&rotation=0&showTitle=false&size=54846&status=done&style=none&taskId=u2f4b6c82-5a99-4cb5-b132-e0fa1bdee22&title=)
我们可以清楚的看到有部分js文件的下载时长还是偏长的，达到100多毫秒。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700798422076-f8bb45e1-eddf-4edd-a01e-a44d2083e5b6.png#clientId=ucf2de2ef-fb58-4&from=paste&height=102&id=u247ad446&originHeight=203&originWidth=804&originalType=binary&ratio=2&rotation=0&showTitle=false&size=25026&status=done&style=none&taskId=u670a595b-9c29-4dc1-9f32-e64cbadbb08&title=&width=402)
**task分析**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700796956892-41d30ae0-bc2e-4643-9d7e-145363e7aa08.png#clientId=ucf2de2ef-fb58-4&from=paste&height=321&id=TQhAu&originHeight=642&originWidth=1745&originalType=binary&ratio=2&rotation=0&showTitle=false&size=140885&status=done&style=none&taskId=u3c394f3a-5210-4b3b-b96b-dc32d8c5960&title=&width=872.5)
**我们为什么要拆分task？**
主线程是在浏览器中运行大多数任务的位置。我们将它称为主线程，是因为它是一个线程，我们编写的几乎所有 JavaScript 都会在这个线程中工作。
主线程一次只能处理一个任务。如果任务的延时时间超过某一点（确切来说是 50 毫秒），则会被归类为耗时较长的任务。如果用户在运行耗时较长的任务时尝试与网页互动，或者如果需要进行重要的呈现更新，浏览器在处理相应工作时会延迟。这会导致交互或呈现延迟。

您需要将任务_拆分_。也就是说，需要将一个较长的任务分成若干个更小的任务，分别耗时较少的任务。直观呈现单个长任务与拆分成五个较短任务的区别。
这一点很重要，因为当任务拆分后，浏览器有更多机会响应优先级较高的工作，其中包括用户互动。
![a-single-long-task-versus-724bb5ecd4b3f_1920.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701087370085-249c94e6-74fa-471e-b7c2-7017a6303811.png#clientId=u5e23611d-d817-4&from=ui&id=u4d84a94f&originHeight=349&originWidth=1155&originalType=binary&ratio=2&rotation=0&showTitle=false&size=5434&status=done&style=none&taskId=uf8c75274-567f-47b0-bb44-c192e2efd47&title=)
与较长的任务被拆分为多个较小的任务相比，当任务过长且浏览器无法足够快地响应互动时，互动会发生什么情况。
![a-depiction-how-breaking-999bc2dd02872_1920.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701087328816-1bfa4bd0-27f8-4cd1-b09d-67b2300a6b13.png#clientId=u5e23611d-d817-4&from=ui&id=u32066e79&originHeight=647&originWidth=1155&originalType=binary&ratio=2&rotation=0&showTitle=false&size=11989&status=done&style=none&taskId=u470c4351-378e-418d-afd1-e4dfcc1ec77&title=)
在上图的顶部，由用户互动排队的事件处理脚本必须等待单个较长的任务才能运行，这会延迟交互的发生。在底部，事件处理脚本有机会更快地运行。因为事件处理脚本有机会在一些小任务之间运行，所以它的运行速度比必须等待较长的任务完成时要快。在上方的示例中，用户可能注意到了延迟；在底部的示例中，互动感觉像是即时互动。
代码让出主线程的思路：

1. dynamic import(async script)/setTimeout/MessageChannel/setImmediate/requestIdleCallback/requestAnamitionFrame/scheduler.yield(需要申请 [源试用进行试用](https://developer.chrome.com/origintrials/?hl=zh-cn#/view_trial/836543630784069633)) 实现让出浏览的主线程。
```javascript
function yieldToMain () {
  return new Promise(resolve => {
    setTimeout(resolve, 0);
  });
}
```

2. isInputPending 来判断用户是否与页面发生交互。
```javascript
while (tasks.length > 0) {
    if (navigator.scheduling.isInputPending()) {
      await yieldToMain();
    } else {
      const task = tasks.shift();
      task();
    }
  }
}
```

3. deadline 用于task分割或者兜底。
```javascript
let deadline = performance.now() + 50;
while (tasks.length > 0) {
  if (navigator.scheduling?.isInputPending() || performance.now() >= deadline) {
    await yieldToMain();
    deadline = performance.now() + 50;
    continue;
  }
  const task = tasks.shift();
  task();
}
```

4. postTask 用于辅助设置任务的优先级。
```javascript
function saveSettings () {
  // Validate the form at high priority
  scheduler.postTask(validateForm, {priority: 'user-blocking'});
  // Update the database in the background:
  scheduler.postTask(saveToDatabase, {priority: 'background'});
};
```
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1702264540517-ffa3f92f-701a-4971-a6a7-f386b0ac2c86.jpeg)
### network面板
打开network面板，首先我们需要停用缓存，来防止浏览器将我们的下载资源进行缓存，这样可以反应更加真实的用户首屏加载。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701865384838-3fdb72c9-5d69-4c0b-bb9d-4c0fe8d85dfa.png#clientId=uc2aa7ee6-037a-4&from=paste&height=316&id=iktSM&originHeight=632&originWidth=1724&originalType=binary&ratio=2&rotation=0&showTitle=false&size=497082&status=done&style=none&taskId=u14b11735-cb3d-4d71-9a3c-fceaa1f767e&title=&width=862)
在看network面板可以很容易的看到所有的请求的并发情况，并逐个对资源进行分析：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701242307504-e90a4485-31db-4038-8f29-ab560573f673.png#clientId=u317d5aec-c704-4&from=paste&height=299&id=jMzFV&originHeight=597&originWidth=1795&originalType=binary&ratio=2&rotation=0&showTitle=false&size=191166&status=done&style=none&taskId=u10a2e6e3-d8c3-4088-9c0d-38756de790e&title=&width=897.5)
通过过滤可以只展示一种类型的资源下载情况，更好的定位接口并发和资源下载问题：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1699844880686-7c950727-977d-454a-b36c-015daac81db8.png#clientId=u141a5175-20e6-4&from=paste&height=649&id=euFDX&originHeight=1298&originWidth=2790&originalType=binary&ratio=2&rotation=0&showTitle=false&size=670456&status=done&style=none&taskId=uceffa56c-b75a-44bd-a489-6208c5bc5ee&title=&width=1395)
### Memory检测
内存问题很重要，因为用户通常可以察觉到这些问题。用户可以通过以下方式感知内存问题：

- **网页的性能随着时间的推移逐渐下降。**这可能是内存泄漏的症状。内存泄漏是指页面中的 bug 导致页面在一段时间内使用的内存越来越多。
- **网页性能一直很糟糕**。这可能是内存膨胀的症状。内存膨胀是指页面为实现最佳速度而使用的内存超过所需内存。
- **网页呈现延迟现象或经常暂停。**这可能是垃圾回收频繁的表现。垃圾回收是指浏览器收回内存。浏览器会决定何时进行此操作。回收期间，所有脚本执行都将暂停。因此，如果浏览器经常进行垃圾回收，脚本执行就会被频繁暂停。

打开**devTools**的**Memory**功能，不断的点击菜单切换路由，截取多个内存快照分析是否有**内存溢出**情况。

- 资源的占用从一开始的 **26mb** 到后面提升到了 **29mb**，
- 但是随着页面切换又回落到了 **26mb**，
- 且停留部分时间内存没有增加，显然内存占用非常健康。

后期如果发生页面卡顿情况再针对性优化分析。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701056470966-06369013-3ff8-45cd-8c84-ca902a254863.png#clientId=ue4bffedf-e630-4&from=paste&height=750&id=LuZjQ&originHeight=1500&originWidth=3582&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1046673&status=done&style=none&taskId=ucecdd473-5278-41ec-8a35-348260e8bec&title=&width=1791)
也可以配合性能监控器一起检查当前页面的dom数量，js堆大小等，每一次快照都会马上执行一次垃圾回收来清除无用的js资源。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701844258360-eb5f408b-a9c9-47da-8167-16d37f3d2468.png#clientId=u00525b39-300b-4&from=paste&height=972&id=u9700d55f&originHeight=1944&originWidth=3582&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1970790&status=done&style=none&taskId=ufd117a2b-4497-4986-b824-c6609957dae&title=&width=1791)
### Lighthouse
谷歌官方的性能优化评分工具，可以给出性能，无障碍，最佳做法，SEA等指标值，并且给出相应的优化意见。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701765178028-3d045dfb-916c-4760-bb64-63aaec7634cc.png#clientId=u066ef871-61f3-4&from=paste&height=750&id=u4e128bdc&originHeight=1500&originWidth=1892&originalType=binary&ratio=2&rotation=0&showTitle=false&size=576468&status=done&style=none&taskId=u5373ca27-1da7-41f6-bac2-5e85474b6b0&title=&width=946)
链接建议：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701765198655-73dd3655-8cbd-4141-9333-3830b8672ca7.png#clientId=u066ef871-61f3-4&from=paste&height=689&id=ud5074be6&originHeight=1378&originWidth=1634&originalType=binary&ratio=2&rotation=0&showTitle=false&size=461077&status=done&style=none&taskId=uab8ce742-d8f3-4c43-b856-c923440bc80&title=&width=817)
CLS偏移意见：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701765280786-7d07ada3-6905-4da0-a7b5-aca76f57c042.png#clientId=u066ef871-61f3-4&from=paste&height=390&id=ue028009e&originHeight=780&originWidth=1484&originalType=binary&ratio=2&rotation=0&showTitle=false&size=254278&status=done&style=none&taskId=ua877b939-df89-4484-89a3-a956c762dbd&title=&width=742)
### 打包分析
包体积分配不均，有几个比较大的包一旦首屏加载会比较拖慢加载时间。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700204034689-16c1be23-20c2-433f-b9ac-5ffe44630fbb.png#clientId=u499a2040-4c7d-4&from=paste&height=625&id=I2NbV&originHeight=1250&originWidth=2560&originalType=binary&ratio=2&rotation=0&showTitle=false&size=754013&status=done&style=none&taskId=u87a0652f-7077-4a69-901e-c18f17edcff&title=&width=1280)
资源总体积打包后来到了3mb的大小：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700739256787-62d2de2e-6f7c-4fd0-9f31-f37b4fc60e4a.png#clientId=u76628f32-d618-4&from=paste&height=184&id=Y2tuq&originHeight=682&originWidth=1340&originalType=binary&ratio=2&rotation=0&showTitle=false&size=501036&status=done&style=none&taskId=u4a99ee40-ff71-40d8-a8e6-d24f4847e6d&title=&width=362)
 问题分析：
8982资源chunk比较大，拆分方式有待提高：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700204144556-2dd5c65d-1c1c-4f60-9ef1-cf566618f8d5.png#clientId=u499a2040-4c7d-4&from=paste&height=326&id=u9e030d1a&originHeight=651&originWidth=924&originalType=binary&ratio=2&rotation=0&showTitle=false&size=168686&status=done&style=none&taskId=u7e6e7053-c20d-4794-a50b-27a992c3099&title=&width=462)
合身组建 @alife/kernel-check 问题比较大，一个人占了1/3的包体积,切忌不能让齐首屏加载
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700204215031-92b5d4fe-6aff-49fd-8de3-0e46520133ef.png#clientId=u499a2040-4c7d-4&from=paste&height=321&id=u48a792f4&originHeight=642&originWidth=552&originalType=binary&ratio=2&rotation=0&showTitle=false&size=98932&status=done&style=none&taskId=u3f546a99-8ada-4aa8-83e9-b1602bb3d93&title=&width=276)
同时使用了mement和dayjs 两个时间包
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700204317486-1817c2af-ad06-4050-bce5-0315b267e188.png#clientId=u499a2040-4c7d-4&from=paste&height=345&id=u85a216d7&originHeight=690&originWidth=1832&originalType=binary&ratio=2&rotation=0&showTitle=false&size=162215&status=done&style=none&taskId=u70724ee3-b070-4790-9ef3-2059fb73b1b&title=&width=916)
忽略了fusion 组建但是包还是打进去了fusion, 并且整体有 **842.8 KB** 的大小。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700742563791-b40b2172-9846-4985-bb6d-08292a7ffe59.png#clientId=u8180a1ab-c3d3-4&from=paste&height=620&id=uc70867c3&originHeight=1239&originWidth=2553&originalType=binary&ratio=2&rotation=0&showTitle=false&size=988642&status=done&style=none&taskId=uaa80546e-5d3f-4d5a-a83b-e12d0c9cf84&title=&width=1276.5)
重复不同版本的资源：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701162491305-d89cc489-9cbd-45c7-b19d-bafd2a299252.png#clientId=u6181706f-4fa4-4&from=paste&height=528&id=u077b0746&originHeight=1056&originWidth=1672&originalType=binary&ratio=2&rotation=0&showTitle=false&size=318839&status=done&style=none&taskId=uca8649c4-ed47-404a-9972-206be6c3627&title=&width=836)
## 性能优化
方案设计：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701175570232-68d06c5a-e57b-4baa-b97e-603461eadf07.jpeg)
### 资源的预链接
**前置：**
同一时间，**多个请求**都发送给同一个服务器，会导致**DNS解析**多次**重复触发**。这样会使整体的网页加载有延迟的情况。（每当浏览器向服务器发送一次请求时，都要先通过**DNS解析**将该跨域域名解析为 IP地址，然后浏览器才能发出请求）
虽然DNS解析占用不了多大带宽，但是它会产生很高的**延迟**。因此，为了减少DNS解析产生的延迟，我们可以通过**预解析技术**有效地缩短DNS解析时间。
> 详细原理参考：[dns-prefetch 预解析技术-- 前端网络必知]()

**问题：**
下面是我们lighthouse的优化建议：

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701765198655-73dd3655-8cbd-4141-9333-3830b8672ca7.png#clientId=u066ef871-61f3-4&from=paste&height=689&id=KKSpd&originHeight=1378&originWidth=1634&originalType=binary&ratio=2&rotation=0&showTitle=false&size=461077&status=done&style=none&taskId=uab8ce742-d8f3-4c43-b856-c923440bc80&title=&width=817)
过多DNS解析： 页面在初始化的时候有比较多的DNS地址被调用，由于浏览器的并发能力会导致同一个DNS地址的资源在短时间内被多次解析，有较大提升空间。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701849748984-cd62b031-bfce-4fc7-8b7f-da711cdffac6.png#clientId=u3439a688-d885-4&from=paste&height=599&id=u63206532&originHeight=1198&originWidth=1140&originalType=binary&ratio=2&rotation=0&showTitle=false&size=820094&status=done&style=none&taskId=ufc6bc8c5-0bcb-447a-b90d-edc16fa0788&title=&width=570)
**解决：**
预连接： 添加 `preconnect` 或 `dns-prefetch` 资源提示，以尽早与重要的第三方源建立连接。
> `<link rel="preconnect">` 会告知浏览器您的网页打算与另一个源站建立连接，您希望该过程尽快开始。
> 在速度较慢的网络中建立连接往往需要很长时间，尤其是在安全连接方面，因为这可能涉及 DNS 查找、重定向以及多次往返于处理用户请求的最终服务器。

注意：虽然 `<link rel="preconnect">` 便宜，但它仍然会占用宝贵的 CPU 时间，尤其是在安全连接上。如果没有在 10 秒内使用连接，此问题尤其糟糕，因为浏览器会关闭连接，浪费所有早期连接工作。
> `<link rel="dns-prefetch">` 是与连接相关的另一种 <link> 类型。这种方式仅处理 DNS 查找，但获得了更广泛的浏览器支持，因此可以作为出色的后备方案。其使用方式完全相同。

**配置diamond，head下增加如下预链接：**
```javascript
<link rel="dns-prefetch" href="https://at.alicdn.com">
<link rel="dns-prefetch" href="https://g.alicdn.com">
<link rel="dns-prefetch" href="https://aeis.alicdn.com">
<link rel="dns-prefetch" href="https://assets.alicdn.com">
```
**结果：**
优化前：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701847930000-7abf8224-f51e-48dc-b918-940255c4df15.png#clientId=ua521a080-54db-4&from=paste&height=471&id=bNS47&originHeight=942&originWidth=3582&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1204118&status=done&style=none&taskId=u166758fd-eb0d-41e7-b3fa-ef49f88a44b&title=&width=1791)
优化后：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701848051616-03eb73e0-1fbb-46ec-b845-2cc53093d9ca.png#clientId=ua521a080-54db-4&from=paste&height=450&id=ubf0dae59&originHeight=900&originWidth=3582&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1201103&status=done&style=none&taskId=u9985d126-a803-458b-9a09-f63a51a2717&title=&width=1791)
可以看到所有来自 [https://assets.alicdn.com](https://assets.alicdn.com) 的cdn资源的下载速度有比较大的提升，从之前的500多ms，提升到了300多ms， 总体相关dns资源速度提升 `40%`。
### 图片资源
**前置：**
图片资源往往占用着很多的资源体积和请求并发，并且其有很多的优化替代方案，比如雪碧图，iconfont，base64，webp等，最终的产物体积和并发量的下降会有非常显著提升，所以图片的优化至关重要。
**问题：**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700547605082-b27dda21-50f3-4e4d-a8f4-95f4e80be93c.png#clientId=uc5c526bf-b688-4&from=paste&height=219&id=uec11e8c8&originHeight=438&originWidth=2690&originalType=binary&ratio=2&rotation=0&showTitle=false&size=374471&status=done&style=none&taskId=u86d450cb-af78-4077-a204-789dbabc26e&title=&width=1345)
小图片过多，占用网络并发。
**解决：**

1. **替换组建：**

定位代码：，图片资源主要来自页面头部引入了 `@alife/chc-mod-navigator`资源包，这个页头组建还会无端引入一个无用的 **跨境卖家中心图片**，并且开发者手动在初始化时获取dom节点，更新图片src资源:
```typescript
useEffect(() => {
  document.documentElement.style.setProperty('--dynamic-content-account', `"${cspShopInfo?.account}"`);
  const imgElement = document.querySelector('.navigator-component_leftImg img') as HTMLImageElement;
  if (imgElement) {
    imgElement.src = 'https://img.alicdn.com/imgextra/i4/O1CN01fsSzy51axPueSHpjS_!!6000000003396-2-tps-228-72.png';
  }
}, [cspShopInfo]);
```
其内部的很多小图标都是用img来绘制的，这就是请求的来源
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701850216208-bb277d8d-d698-421b-b22f-281373def727.png#clientId=u3439a688-d885-4&from=paste&height=114&id=u196c7343&originHeight=228&originWidth=266&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42025&status=done&style=none&taskId=u831641c0-984c-46b5-b22f-99901a0b30f&title=&width=133)
既然目标组建对于本项目这么不适配，唯一的解决方案就是重写此功能，因为没办法去除组建内部的无用资源引入问题。然后全部将图片替换为**iconfont。**

2. **白屏图片：**

在白屏的时候也会下载一个图片资源，此图片遭到了**UED审核**的反对并且也会占用**首屏并发请求**，所以我们需要实现替换方案。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700188057422-52f57491-7fb7-42c9-b38a-f012b968e7b1.png#clientId=ua38f5858-bfdc-4&from=paste&height=84&id=u18fe6949&originHeight=167&originWidth=1175&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35443&status=done&style=none&taskId=u6265a1d7-9ee3-44d2-88ce-404b19f34e6&title=&width=587.5)
由于在其之前**head**我们已经加载了**fusion主题样式文件**，且对于浏览器的 ref="stylesheet"  有最高的加载优先级。
我们只需要在 `#root`节点内部放入 loading 动画相应的同class dom即可，在css加载完成后立刻出现fusion的loading动画。 
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700188181991-9fa47ab8-6700-4e63-9cd9-e10b962de659.png#clientId=ua38f5858-bfdc-4&from=paste&height=86&id=u6917c7ed&originHeight=172&originWidth=1121&originalType=binary&ratio=2&rotation=0&showTitle=false&size=54998&status=done&style=none&taskId=uab9613bb-c671-43cc-b666-6df87871149&title=&width=560.5)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700188337756-de2f4a76-8d8c-4932-b312-51175a26dc9f.png#clientId=ua38f5858-bfdc-4&from=paste&height=208&id=u05c56b3c&originHeight=416&originWidth=1247&originalType=binary&ratio=2&rotation=0&showTitle=false&size=73834&status=done&style=none&taskId=u7ea29369-714e-4cd1-95e1-a7c9dc4419d&title=&width=623.5)
**loading.tsx **文件,同样加载了我们上面优化掉的图片资源，我们也一并改成 fusion 的dom节点，应用fusion的样式即可。

3. **防止CLS**

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701765280786-7d07ada3-6905-4da0-a7b5-aca76f57c042.png#clientId=u066ef871-61f3-4&from=paste&height=382&id=MeAG3&originHeight=780&originWidth=1484&originalType=binary&ratio=2&rotation=0&showTitle=false&size=254278&status=done&style=none&taskId=ua877b939-df89-4484-89a3-a956c762dbd&title=&width=726)
图片布局偏移：当我们在设置样式的时候只设置的图标的一侧的px值，这会导致浏览器在解析img 的时候无法知道其图片的比例，也就无法确定这个图片的布局占位。唯有等到图片资源下载完毕才可以在重新回流和布局偏移。
所以我们要在img标签上定义好图片的比例：
```javascript
<img
    className={styles.logo}
    width="100"
    height="32"
    alt="logo"
    onClick={() => history.push('/')}
    src="https://img.alicdn.com/imgextra/i4/O1CN01fsSzy51axPueSHpjS_!!6000000003396-2-tps-228-72.png"
  />
```
**结果：**
优化后的图片资源数量从 7个 => 1个，体积从 27kb => 4.7kb, 图片资源体积缩小 `**83%**`**。**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700547887344-613d89bb-03ba-44d9-9110-c63a65d39ce9.png#clientId=uc5c526bf-b688-4&from=paste&height=203&id=ua22e2457&originHeight=406&originWidth=2802&originalType=binary&ratio=2&rotation=0&showTitle=false&size=294475&status=done&style=none&taskId=ua0a8ded2-07fe-4219-8a6a-386a6bda0af&title=&width=1401)
loading动画效果对比：
前：									后：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700193407627-32a30557-7646-4833-a030-f2e4c780c5f8.png#clientId=u43be3060-c811-4&from=paste&height=167&id=Bhy9E&originHeight=1247&originWidth=2560&originalType=binary&ratio=2&rotation=0&showTitle=false&size=57840&status=done&style=none&taskId=udb17f494-2c97-41fd-9ebd-c9ecfc75d80&title=&width=343)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700193322800-ae082945-7d8a-4158-88c1-b20a3e1bd80d.png#clientId=u43be3060-c811-4&from=paste&height=181&id=NF23I&originHeight=1334&originWidth=2560&originalType=binary&ratio=2&rotation=0&showTitle=false&size=318239&status=done&style=none&taskId=ud6d27d9f-8852-4e04-911a-1f8390938cc&title=&width=348)  

### 美杜莎语言资源
**前置：**
作为一个多语言工程，美杜莎资源是不可或缺的，我们需要下载美杜莎提供的各种语言资源包。但是随着项目的复杂度和语言增加会导致体积的几何倍增大，所以根据当前语言按需引入此类资源非常关键。
**问题：**
冗余资源：当前项目中会默认引入全量的中英文，也就是1800*2个key，压缩前体积来到了349kb，并且我们本地的兜底文件也是全量引入相关中英文资源，这会增加网络资源和JS代码解析消耗。
且未来一旦语言增多存在资源体积的隐患。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701850780719-c4f63ae0-a47b-4a2f-b858-6982bcebda66.png#clientId=u3439a688-d885-4&from=paste&height=99&id=u8824f3f1&originHeight=198&originWidth=3312&originalType=binary&ratio=2&rotation=0&showTitle=false&size=334106&status=done&style=none&taskId=u452754d7-e198-4a75-90d1-ae47de212d8&title=&width=1656)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701850994213-4debe3a2-28e0-4cdc-b454-44d1fa525098.png#clientId=u3439a688-d885-4&from=paste&height=41&id=u1b422a93&originHeight=82&originWidth=423&originalType=binary&ratio=2&rotation=0&showTitle=false&size=25970&status=done&style=none&taskId=u0849fafa-14a2-4785-92ee-26daf1b1696&title=&width=211.5)
**解决：**

1. **项目兜底数据：**

本项目有较多的美杜莎多语言兜底文案数据，内部含有中英文各1253个文案，我们需要对其进行瘦身处理，把一些项目中不用到的文案去除。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700449303918-a2ded8a6-9be3-420c-bb20-4b6be25818b8.png#clientId=u9c0b40c2-97fd-4&from=paste&height=162&id=u0680e0a4&originHeight=324&originWidth=411&originalType=binary&ratio=2&rotation=0&showTitle=false&size=21239&status=done&style=none&taskId=u6ce66c5e-509f-460d-a6a3-aaa424c6dec&title=&width=205.5)
书写一个node脚本，递归读取src文件目录，统计使用到的key值，当然要先把一些公共的key值保留下来，因为那些是根据接口返回值动态渲染的。
`unused-must.js`:
```typescript
const fs = require('fs');
const path = require('path');

const whiteKeys =['$.page.services.middlewares.response-handler', '$.page.fund-manage.withdraw.step1.PaymentAccount', '$.page.account-manage.add-account.CurrencyOfReceipt']
function checkKeyUsage(jsonFilePath, folderPath, ignorePath) {
  // 读取 JSON 文件
  const jsonContent = fs.readFileSync(jsonFilePath, 'utf-8');
  const jsonData = JSON.parse(jsonContent);
  const useUsedJson = {};
  const allKeys = Object.keys(jsonData).filter(key => {
    if(whiteKeys.some(item => key.includes(item))) {
      useUsedJson[key] = jsonData[key]
      return false
    }
    return true
  });
  // 递归检查文件夹下的文件
  function checkFiles(directory) {
    const files = fs.readdirSync(directory);
    files.forEach((file) => {
      const filePath = path.join(directory, file);
      const stats = fs.statSync(filePath);

      if (stats.isDirectory()) {
        checkFiles(filePath);
      } else if (stats.isFile() && !file.includes(ignorePath)) {
        const fileContent = fs.readFileSync(filePath, 'utf-8');
        allKeys.forEach((key, index) => {
          if (fileContent.includes(key)) {
            allKeys[index] = undefined
            useUsedJson[key] = jsonData[key]
          }
        })
      }
    });
  }
  checkFiles(folderPath);

  // 输出被删除的 key 值
  allKeys.forEach(key => key && console.log(key))
  console.log(`${jsonFilePath}文件, 删除${allKeys.filter(item => item).length}个key值 ！！`)

  fs.writeFileSync(jsonFilePath, JSON.stringify(useUsedJson, null, 2))
}

// 使用示例
const jsonFilePath = ['./src/i18n/strings/zh-CN.json', './src/i18n/strings/en-US.json'];
const folderPath = './src';
jsonFilePath.forEach(item => checkKeyUsage(item, folderPath, '.json'))

```
删除了中文和英文各 `355` 个无用兜底key值
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700548773378-2b3d107f-ecd5-47e9-b247-048afed26c97.png#clientId=uc5c526bf-b688-4&from=paste&height=155&id=uc0ea1323&originHeight=309&originWidth=673&originalType=binary&ratio=2&rotation=0&showTitle=false&size=65042&status=done&style=none&taskId=ued739cdc-84db-4cf2-8c43-352d02e6e70&title=&width=336.5)
其次我们兜底文件只需要一份语言即可，不需要太多，因为我们服务的大部分客户是东南亚和香港的华人，所以我们选择留一份中文的数据即可。

2. **线上CDN数据：**

我们线上还是需要按照当前语言动态引入资源的策略。
美杜莎支持加上对应`小写的`语言后缀 `_${lang}`就可以导入对应的语言资源, 比如:
> https://y.alicdn.com/daily/AEPAY_MERCHANT_WALLET/0.0.1/AEPAY_MERCHANT_WALLET_`cn-zh`.json

所以我们需要用 [VM 语法](https://velocity.apache.org/engine/devel/user-guide.html) 在 [diamond](https://mse.alibaba-inc.com/aliyun-region-vpc-ap-southeast-1-pre/diamond/configlist/configedit?DataId=dada.page.app&Group=AEPAY&AppName=global-merchant-portal-f&tab=edit) 上配置对应的 获取 `cookie的 _lang`值动态设置我们的美杜莎资源链接地址
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700814096600-4e567a8a-13cf-4973-a386-53cac7e95a57.png#clientId=u3e91d62c-fe23-4&from=paste&height=221&id=u2c29ba00&originHeight=450&originWidth=1826&originalType=binary&ratio=2&rotation=0&showTitle=false&size=383113&status=done&style=none&taskId=u356c2e27-f5ae-49ae-98c7-3204ff07e75&title=&width=896)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700814116212-0c26ec49-1c64-42cb-9dc5-266494c3b299.png#clientId=u3e91d62c-fe23-4&from=paste&height=98&id=u8b48580a&originHeight=196&originWidth=1504&originalType=binary&ratio=2&rotation=0&showTitle=false&size=98615&status=done&style=none&taskId=u085674d8-3e2d-472a-b204-b087652f4a1&title=&width=752)
**结果：**
本地资源体积从 **193kb** => **66kb** , 缩小 `**65.8%**`。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700548426195-a6ad5b71-cc52-491b-9121-26ab99acb7aa.png#clientId=uc5c526bf-b688-4&from=paste&height=71&id=QUpkP&originHeight=142&originWidth=1556&originalType=binary&ratio=2&rotation=0&showTitle=false&size=54140&status=done&style=none&taskId=u0b93105a-c7d3-4cf8-97e1-974c4fdeb0c&title=&width=778)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700548792622-46b75d7f-774c-4a3f-973d-81dade70de84.png#clientId=uc5c526bf-b688-4&from=paste&height=67&id=cp0Dj&originHeight=134&originWidth=1588&originalType=binary&ratio=2&rotation=0&showTitle=false&size=54753&status=done&style=none&taskId=u0969594b-cb03-46fc-a9ab-4e01f6c02f1&title=&width=794)
线上CDN资源压缩前体积从 **348kb** => **169kb** , 缩小 `**51.4%**`。总体缩小：`306kb，56%`。
### 依赖优化
**前置：**
一个项目的依赖整洁对于整个项目的运行和后期维护至关重要，过多的引入冗余依赖不但会增加项目体积还会增加开发人员的心智负担，降低可维护性。所以我们需要对整个工程的依赖进行整理和优化。
**问题：**
有较多小包和冗余依赖：项目内含有过多的依赖文件，所有引入的资源对于开发人员来讲是一个黑盒，只有分析打包chunk的时候，才会发现问题，增加了长期维护难度。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701851969681-5b1472b0-ec74-4b7d-b3dc-e8996e1fd47e.png#clientId=u3439a688-d885-4&from=paste&height=295&id=u815091a1&originHeight=590&originWidth=509&originalType=binary&ratio=2&rotation=0&showTitle=false&size=237314&status=done&style=none&taskId=ubb1d355d-8683-4968-bd22-02b22065d9d&title=&width=254.5)
重复引入的时间依赖：moment和dayjs都是时间依赖，两个同时存在，占用资源体积：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700204317486-1817c2af-ad06-4050-bce5-0315b267e188.png#clientId=u499a2040-4c7d-4&from=paste&height=345&id=xLb3e&originHeight=690&originWidth=1832&originalType=binary&ratio=2&rotation=0&showTitle=false&size=162215&status=done&style=none&taskId=u70724ee3-b070-4790-9ef3-2059fb73b1b&title=&width=916)
重复版本的资源：项目中有比较多的重复依赖，比如 **bn.js **有**5.2.1**和**4.12.0**两个版本， 还有像**readable-stream **也有两个版本， 这种资源内部会有非常多的重复率，增加了我们chunk包的体积。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701224234850-85ec553c-0c41-4e98-b99d-65d938cabeb3.png#clientId=u1937e4b6-50a2-4&from=paste&height=474&id=uPcq5&originHeight=947&originWidth=1500&originalType=binary&ratio=2&rotation=0&showTitle=false&size=364656&status=done&style=none&taskId=u90c39157-2804-44e1-978a-43b2ba4ddfd&title=&width=750)
**解决：**

1. **无用或未使用的依赖删除：**

`@alife/intl-util`
`@alife/member-user-auth` 会员登陆注册管理

2. **简单冗余依赖**

`@alife/chc-mod-navigator`、 `@alife/chc-mod-result`、`@alife/chc-mod-tab`、`@alife/chc-mod-state`
几个包功能比较简单就是一个结果页的展示，且依赖 `moment`等其他的包，所以本地直接删除简单书写工程内组建即可。

3. **替换 monent**

**fusion历史问题**：使用moment是因为 fusion 的历史遗留原因。大部分的包为了兼容 fusion组建，都是引入了 moment 依赖，而moment其本身是一个极其重的时间依赖，并且它也不支持按需引入的方式使用，打包完去除了语言资源体积也来到了`69kb`。
**支持dayjs**：但是我们在使用fusion相关时间组建的时候，使用的是 datepicker2 ，其是完全支持dayjs。考察完依赖后确定所有相关依赖是可以完全脱离moment的。
但是有一个问题，其资源是在依赖的包里被引入的，并不是我本地工程的代码，该怎么办？
**alias 替换**：得益于moment和dayjs的api大部分都相同，所以我们可以将所有的moemnt全部替换为dayjs，我们使用 umi的 alias 能力将所有的moment引入在打包时全部替换成 dayjs。
**config.ts**
```
alias: {
  moment: 'dayjs',
},
```
打包后允许相关时间组建功能无异常，且chunk中moment资源也消失了。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700550253880-3eb4aa33-20b6-4ae1-a2e3-e22eb2f92309.png#clientId=ud4a199e3-e0da-4&from=paste&height=244&id=ud95f7afe&originHeight=598&originWidth=1840&originalType=binary&ratio=2&rotation=0&showTitle=false&size=151447&status=done&style=none&taskId=u27fea7cb-fabd-411b-b3b4-3e8f0e3b290&title=&width=750)

4. **packages.json resolutions**

解决不同版本的重复资源：package.json 文件中的"resolutions" 参数。 它是一个特殊的字段，**提供对其他依赖项的版本限制**。 当依赖项的版本冲突时，使用"resolutions" 字段可以告诉npm 哪个版本应该被安装。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701224234850-85ec553c-0c41-4e98-b99d-65d938cabeb3.png#clientId=u1937e4b6-50a2-4&from=paste&height=474&id=u17f620ca&originHeight=947&originWidth=1500&originalType=binary&ratio=2&rotation=0&showTitle=false&size=364656&status=done&style=none&taskId=u90c39157-2804-44e1-978a-43b2ba4ddfd&title=&width=750)
我们在查阅相关兼容性和测试无问题之后，定义了如下依赖的版本合并
```json
"resolutions": {
  "@alifd/next": "~1.25.51",
  "@alife/theme-csp-seller": "^0.12.0",
  "bn.js": "~5.2.1",
  "moment": "~2.29.4",
  "react": "^17.0.2",
  "react-dom": "^17.0.2",
  "readable-stream": "~2.3.8"
},
```
再次打包后多个版本的依赖就消失了，变成了一个版本，资源体积也减少了 110kb。
**结果：**
整体减少了**7个依赖包**，资源体积缩小了**230kb。**
### 资源externals 和 CDN
**前置：**
> CDN的全称是Content Delivery Network，即内容分发网络。由于CDN是为加快网络访问速度而被优化的网络覆盖层，因此被形象地称为“网络加速器”。

主要思路： 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。
实现方法**：**通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接和负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上，加快访问速度。
目的：** **使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。
优势：

1. CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；
2. 大部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。

详情参考 [前端必需了解的CDN知识](https://juejin.cn/post/6913704568325046279?searchId=2023120616503980BF3378513E0B77ACD5)
**问题：**
在我们的项目中有较多的公共资源，比如react相关的：react、react-dom，还有就是组建库资源：@alifd/next。
每一次的打包部署都会打入新的资源版本，导致用户之前的资源无法被缓存。
且这些资源属于公共的资源，很多的项目都会用到，这些资源在阿里内部都有CDN的部署。
**解决：**

1. **基本配置**

配置externals属性：将上面提到的资源进行忽略, 分别是忽略了 `react`, `react-dom`和 `@alife/next`组建库。
 [umi-plugin-intl](https://web.npm.alibaba-inc.com/package/@ali/umi-plugin-intl) 组建定义资源版本以及 host地址：其会自动生成相应的  [nunjucks](https://mozilla.github.io/nunjucks/)  变量，用于在 **daimond **上解析生成对应地址的 cdn script标签。
```json
{
  externals: {
    react: 'React',
    'react-dom': 'ReactDOM',
    '@alifd/next': 'Next'
  },
  plugins: ['@ali/umi-plugin-intl'],
  pluginIntl: {
    renderProps: {
      versions: {
        react: '17.0.2',
        next: '1.25.51',
        theme: '0.12.0',
      },
    	assetsHost: 'https://assets.alicdn.com/g',
    }
  }
}

```
```json
<script crossorigin src="{{ assetsHost }}/code/lib/react/{{ versions.react }}/umd/react.production.min.js"></script>
<script crossorigin src="{{ assetsHost }}/code/lib/react-dom/{{ versions.react }}/umd/react-dom.production.min.js"></script>
<script crossorigin src="{{ assetsHost }}/code/lib/alifd__next/{{ versions.next }}/next.min.js"></script>
```

2. **逐个击破**

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700731315679-a19568ba-b9cc-4cef-88de-3fd2806493e3.png#clientId=ud0f95b97-a934-4&from=paste&height=413&id=XfRoq&originHeight=825&originWidth=1060&originalType=binary&ratio=2&rotation=0&showTitle=false&size=214354&status=done&style=none&taskId=uce998aa7-d426-4285-b4a7-dc9310dca7f&title=&width=530)
优化后在我们的资源chunk图内还是出现了 `@alife/next` 的资源，他可以逃脱 webpack 的extends 语法一定是因为他的资源引入方式和正常的不同，他可能引入的是 `'@alife/next/lib'` 等，所以我们需要去资源定位。 
```javascript
// 正常引入
import { menu } from '@alife/next'
// 其他方式
import Next from '@alife/next/lib'
const menu = Next.menu
```
主要是因为`from`后面字符串不匹配导致的
问题定位：这个包是打在layout_normal 路由下，我们去查看代码发现我们在次路由下的组建有引入一个 `@alife/chc-mod-menu`的组建框。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700733320132-3e55c662-7942-4853-beb4-39fb3a360d9a.png#clientId=ud0f95b97-a934-4&from=paste&height=175&id=tvHqC&originHeight=350&originWidth=803&originalType=binary&ratio=2&rotation=0&showTitle=false&size=79342&status=done&style=none&taskId=u2917a670-c145-4d33-b37e-7dafd21b74d&title=&width=401.5)
在 `anpm` 进行搜索其资源包以及问题定位后，发现其引入名称是 `@alife/next/lib/nav`。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700733415384-fa4e7fd5-78e0-4298-bbd1-85a7ca9c0a9c.png#clientId=ud0f95b97-a934-4&from=paste&height=177&id=B6Mfq&originHeight=353&originWidth=754&originalType=binary&ratio=2&rotation=0&showTitle=false&size=74030&status=done&style=none&taskId=uf56ff9bb-0761-4dd1-8132-0cf2361cef2&title=&width=377)
配置 umi 忽略 `'@alife/next/lib/nav'` 并承接上一个全局变量的 `Next`的名称获取 `.Nav`即可
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700733614184-4b10b0fe-87f1-4fed-a817-2e1b00368aa7.png#clientId=ud0f95b97-a934-4&from=paste&height=123&id=Hsun4&originHeight=246&originWidth=400&originalType=binary&ratio=2&rotation=0&showTitle=false&size=30738&status=done&style=none&taskId=ufeffc178-92db-4efd-9edd-8eeb341e86c&title=&width=200)
```
{
	externals: {
    react: 'React',
    'react-dom': 'ReactDOM',
    '@alifd/next': 'Next',
    '@alife/next/lib/nav': 'Next.Nav',
  },
}
```

**结果：**
资源包内体积从`3.4mb`减少到了 `2.43mb`。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701853732700-b7a1da7c-c5c9-4a5f-8dfa-7da243e3059a.png#clientId=u3439a688-d885-4&from=paste&height=93&id=u9caf2091&originHeight=186&originWidth=467&originalType=binary&ratio=2&rotation=0&showTitle=false&size=65494&status=done&style=none&taskId=uc2320495-b534-48ac-ac23-5fac7a8851b&title=&width=233.5)
搜索 @alifd/next 也只剩下了11kb的语言文件：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701853556625-9454bf16-cf0e-4595-9323-23780360bed5.png#clientId=u3439a688-d885-4&from=paste&height=92&id=u85bb194f&originHeight=183&originWidth=527&originalType=binary&ratio=2&rotation=0&showTitle=false&size=71258&status=done&style=none&taskId=u823fa439-5a72-4067-9fe1-054aa2ab498&title=&width=263.5)

### 交互优化
**前置：**
骨架屏：是页面的一个空白版本，通常会在页面完全渲染之前，通过一些灰色的区块大致勾勒出轮廓，待数据加载完成后，再替换成真实的内容。可以给用户更好的页面加载体验，减少等待焦虑。
**问题：**
在我们的项目中所有的页面都没有骨架屏，这导致页面在刚刚进去的时候都是一个空白页，然后突然闪了一下内容出现，交互体验差，且会增加用户的等待焦虑。
资金管理相关页面在输入金额变动时，手续费，兑换金额等会实时的请求更新。这没有一个动画告知用户在更新数据，所以我们可以加入**loading动画过度。**
**结果：**
我们分别给概览、资金管理相关页面、账户管理相关页面加上骨架屏
优化前：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700792884955-0423470f-b902-4230-b200-6ff71f697ec7.png#clientId=ua985a20f-9bc5-4&from=paste&height=595&id=ua097387e&originHeight=1190&originWidth=2559&originalType=binary&ratio=2&rotation=0&showTitle=false&size=68984&status=done&style=none&taskId=uf5f729f1-43d7-4f6e-8dac-be0a080c01f&title=&width=1279.5)
优化后：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701337579310-ced62974-1c5d-4fa9-9d62-6850461e874c.png#clientId=u514b06d4-8cf4-4&from=paste&height=582&id=ub65ee4ae&originHeight=1163&originWidth=2557&originalType=binary&ratio=2&rotation=0&showTitle=false&size=161265&status=done&style=none&taskId=ub6687224-f0b0-422f-b7f6-742622930fa&title=&width=1278.5)
给所有资金管理页面增加金额变动动画，输入loading：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701755580907-af95d917-7c28-4790-805e-21831b34322a.png#clientId=uc254915a-6688-4&from=paste&height=184&id=u860ca50f&originHeight=367&originWidth=747&originalType=binary&ratio=2&rotation=0&showTitle=false&size=20157&status=done&style=none&taskId=u9fd2c1e8-b77f-4bab-a3be-6027b3365dc&title=&width=373.5)
### terser 压缩
**前置：**
**terser**和**esbuild**都是用于JavaScript代码压缩和优化的工具，它们在功能上有一些相似之处，但也有一些不同之处。
**terser**是一个广泛使用的JavaScript压缩器，可以将代码**压缩到最小**，并且可以**删除未使用的代码**、**重复代码**和**注释**等内容。**terser**支持多种JavaScript语言特性，包括ES6、ES7、ES8等。**terser**的一个优点是它的压缩速度比较快，但是压缩率可能不如其他一些更高级的JavaScript压缩器。
**esbuild**是一个新兴的JavaScript构建工具，它可以在非常短的时间内快速构建JavaScript代码，并且可以使用多种不同的构建目标，包括ES5、ES6、CommonJS和AMD等。**esbuild**的一个显著优点是它的构建速度非常快，可能比其他一些构建工具快几倍甚至几十倍。除此之外，**esbuild**还支持一些高级的JavaScript特性，如Tree Shaking等。
综上所述，**terser**和**esbuild**都是用于JavaScript代码压缩和优化的工具，它们在功能上有些相似，但也有些不同之处。如果需要在**构建时间上优化**，则**esbuild**可能是更好的选择，而如果需要**更高的压缩率**，则**terser**可能更适合。但是，对于具体情况，最好进行测试和评估，以确定哪个工具最适合您的需求。
**问题：**
umi 默认的压缩工具是esbuild，也就是在jsMinifier 内配置的，但是esbuild的压缩方法优先，就只有简单的三项，压缩效率可以尝试和其他工具对比。
```javascript
{
  jsMinifier: 'esbuild',
  jsMinifierOptions: {
    minifyWhitespace: true,
    minifyIdentifiers: true,
    minifySyntax: true,
  }
}
```
**解决：**
我们可以采用更成熟的terser进行代码压缩，且对于ES5过去语法的支持更加优异，另外加上一个去除 console.log的配置项。
config.ts
```javascript
  jsMinifier: 'terser',
  jsMinifierOptions: {
    compress: {
      drop_console: true, // 移除所有 console.log
    },
  },
```
**结果：**
`terser`可以更好的透视我们的chunk内部子包分布，可以看看对比两者在打包产物analyze分析的umi.js 内部分布的区别：
esbuild:								terser:
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701176384861-141bcc8d-4cc5-4d46-a80d-241a504b0e12.png#clientId=u72f5e253-d967-4&from=paste&height=179&id=u84241644&originHeight=1250&originWidth=2493&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1722068&status=done&style=none&taskId=u8c8df54a-3062-4f9a-b300-8263720b416&title=&width=357)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701176254351-f3598be5-faf3-43ff-841f-e4dc6e41761c.png#clientId=u72f5e253-d967-4&from=paste&height=179&id=u9cd652bb&originHeight=1249&originWidth=2488&originalType=binary&ratio=2&rotation=0&showTitle=false&size=427589&status=done&style=none&taskId=u223d820f-6557-478e-86d5-f980d2abb91&title=&width=357)
包体积对比，体积缩小 `5.8%`。
优化前：									优化后：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700814650722-891ed074-3f6f-4423-a63d-85e8c061e8dd.png#clientId=u3e91d62c-fe23-4&from=paste&height=120&id=abDPQ&originHeight=217&originWidth=695&originalType=binary&ratio=2&rotation=0&showTitle=false&size=58707&status=done&style=none&taskId=u5b922241-01f5-408d-aeec-ba20909776f&title=&width=383.5) ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701175899332-faa65409-7f01-44e1-8f78-59149ad72a5f.png#clientId=u72f5e253-d967-4&from=paste&height=127&id=u2ae8b415&originHeight=277&originWidth=721&originalType=binary&ratio=2&rotation=0&showTitle=false&size=64455&status=done&style=none&taskId=ua90d46be-1b42-4253-8a12-ab4d0c7af90&title=&width=331.5)

### 模块拆分合并
**前置：**
> **module**：指的是应用程序中的一个单独的模块，例如 JavaScript 代码、CSS、图片或其他资源。webpack 将每个模块都视为一个独立的单元，并通过识别模块之间的依赖关系来构建应用程序。
> **chunk**：一个 chunk 是一组相互依赖的 module，它们被组合在一起以便可以并行加载。这样做可以提高应用程序的性能，因为浏览器可以同时加载多个小块而不是一个大文件。一个 chunk 可以是一个入口文件或者由 webpack 自动生成。
> **bundle：**当 webpack 将所有模块打包成一个或多个文件时，这些文件就称为 bundle。一个 bundle 可以包含一个或多个 chunk 和其他资源文件。
> **分包**：在打包时对资源进行划分，来生存自定义大小和数量的模块产物。

**module**、**chunk** 和 **bundle** 其实就是同一份代码在不同转换场景下的三个 webpack 术语名称，源文件是 **module**，webpack 处理时是 **chunk**，最后生成浏览器可以直接运行的代码叫 **bundle**。
在打包产物中，每个bundle资源的大小直接关系到了我们页面在浏览器中的请求资源次数和大小。
过大的bundle占用更多的浏览资源解析时间，也会长时间占用主线程导致 `long task`，阻塞浏览器，从而影响动画更新，交互响应等。
所以合理的分配打包资源的组合和分包很重要，可以最大限度的利用浏览器的并发、下载、解析速度，提高交互体感。
**问题：**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701856404872-e72045f7-25d1-4710-98f3-054444d223e7.png#clientId=ubb929f96-7615-4&from=paste&height=624&id=u0d845f8d&originHeight=1248&originWidth=1705&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1514997&status=done&style=none&taskId=ue2862cf3-5530-499c-91fd-08bfee48c3e&title=&width=852.5)
chunk体积的分配不均匀：资源的分配不均匀会导致首屏加载的资源过多，资源使用覆盖率低，减慢首屏速度。
仔细观察在chunk图内`5518`模块过大，已经超过了警戒线500kb最大体积，甚至超过了umi.js，这显然是一个性能炸弹，虽然其采取了异步措施，但是其资源解析的时候一定会触发**long task，**导致浏览器出现卡顿现象。
**解决：**

1. **splitChunks**

在我们的umi内部默认有一些分包的方案，可以进行chunk的高效分包，下面我们分别尝试来统计结果，并了解其分包策略。

| 分包方式 | 介绍 | chunk图 |  |
| --- | --- | --- | --- |
| `bigVendors` | 是大 vendors 方案，会将 async chunk 里的 node_modules 下的文件打包到一起，可以避免重复。同时缺点是，1）单文件的尺寸过大，2）毫无缓存效率可言。 | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700740752536-e2c28a7e-09fd-4b43-a454-bbf73978fcb3.png#clientId=ud07cda84-50a9-4&from=paste&height=931&id=S1n0f&originHeight=1862&originWidth=3578&originalType=binary&ratio=2&rotation=0&showTitle=false&size=6536464&status=done&style=none&taskId=u4882a0ce-db2b-4549-b7c3-317c6d4288d&title=&width=1789) | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700741860619-34284e96-2899-42b0-8f9d-88c81eb87f92.png#clientId=u6e88d97b-b1e2-4&from=paste&height=88&id=gBP9V&originHeight=176&originWidth=436&originalType=binary&ratio=2&rotation=0&showTitle=false&size=28144&status=done&style=none&taskId=uaa936771-d3f6-4ffe-b903-c264beeacf7&title=&width=218) |
| `depPerChunk` | 和 bigVendors 类似，不同的是把依赖按 package name + version 进行拆分，算是解了 bigVendors 的尺寸和缓存效率问题。但同时带来的潜在问题是，可能导致请求较多。我的理解是，对于非大型项目来说其实还好，因为，1）单个页面的请求不会包含非常多的依赖，2）基于 HTTP/2，几十个请求不算问题。但是，对于大型项目或巨型项目来说，需要考虑更合适的方案。 | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700740884832-fdb7ae39-44d4-4d2b-92cc-c6e6ab8b8017.png#clientId=ud07cda84-50a9-4&from=paste&height=934&id=YRAen&originHeight=1868&originWidth=3576&originalType=binary&ratio=2&rotation=0&showTitle=false&size=3067154&status=done&style=none&taskId=u70c091cc-8703-4e05-8114-eb67a833bc3&title=&width=1788) | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700741792242-1556b432-2e8e-49c5-9644-9585b7c1f08c.png#clientId=u6e88d97b-b1e2-4&from=paste&height=99&id=qE7QT&originHeight=198&originWidth=523&originalType=binary&ratio=2&rotation=0&showTitle=false&size=33156&status=done&style=none&taskId=ueadadbd5-e5c1-4597-971c-8ff3b1546f3&title=&width=261.5) |
| `granularChunks` | 在 bigVendors 和 depPerChunk 之间取了中间值，同时又能在缓存效率上有更好的利用。无特殊场景，建议用 granularChunks 策略。 | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700740990668-ff2afd64-d1d3-4386-8e2b-023c8f150e5c.png#clientId=ud07cda84-50a9-4&from=paste&height=931&id=tJAIH&originHeight=1862&originWidth=3572&originalType=binary&ratio=2&rotation=0&showTitle=false&size=2863598&status=done&style=none&taskId=u13047bb0-7011-4925-a605-0a5a81ba099&title=&width=1786) | ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700741125182-96c0b3ba-aaa0-4928-aa4c-8ac73b92910c.png#clientId=u6e88d97b-b1e2-4&from=paste&height=203&id=TTtde&originHeight=406&originWidth=900&originalType=binary&ratio=2&rotation=0&showTitle=false&size=245557&status=done&style=none&taskId=ubf17f092-c5cf-4633-93af-89b73846584&title=&width=450) |

对应umi分包代码
packages/preset-umi/src/features/codeSplitting/codeSplitting.ts
```javascript
if (jsStrategy === 'bigVendors') {
  memo.optimization.splitChunks({
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        priority: 10,
        name: 'vendors',
        chunks: 'async',
        ...jsStrategyOptions,
      },
    },
  });
}
if (jsStrategy === 'depPerChunk') {
  memo.optimization.splitChunks({
    cacheGroups: {
      vendors: {
        test: /[\\/]node_modules[\\/]/,
        priority: 10,
        chunks: 'async',
        name(module: any) {
          // e.g. node_modules/.pnpm/lodash-es@4.17.21/node_modules/lodash-es
          const path = module.context.replace(/.pnpm[\\/]/, '');
          const match = path.match(/[\\/]node_modules[\\/](.*?)([\\/]|$)/);
          if (!match) return 'npm.unknown';
          const packageName = match[1];
          return `npm.${packageName
                        .replace(/@/g, '_at_')
                        .replace(/\+/g, '_')}`;
        },
      },
    },
  });
}
if (jsStrategy === 'granularChunks') {
  const FRAMEWORK_BUNDLES = [
    'react-dom',
    'react',
    'history',
    'react-router',
    'react-router-dom',
    'scheduler',
  ];
  memo.optimization.splitChunks({
    cacheGroups: {
      default: false,
      defaultVendors: false,
      framework: {
        name: 'framework',
        chunks: 'all',
        test: new RegExp(
          `[\\\\/]node_modules[\\\\/](${FRAMEWORK_BUNDLES.join(
            `|`,
          )})[\\\\/]`,
        ),
        priority: 40,
        enforce: true,
      },
      lib: {
        test(module: any) {
          return (
            !isModuleCSS(module) &&
            module.size() > 160000 &&
            /node_modules[/\\]/.test(module.identifier())
          );
        },
        name(module: any) {
          const rawRequest =
            module.rawRequest &&
            module.rawRequest.replace(/^@(\w+)[/\\]/, '$1-');
          if (rawRequest) {
            return `${
              // when `require()` a package with relative path,
              // need remove leading `.` and `/`, otherwise will not found `.js` file
              // e.g. require('../../lib/codemirror')
              rawRequest.replace(/\./g, '_').replace(/\//g, '-')
            }-lib`;
          }
        	// 模块标识符
          const identifier = module.identifier();
          // 获取 node_modules 后面的部分
          const trimmedIdentifier = /(?:^|[/\\])node_modules[/\\](.*)/.exec(
            identifier,
          );
          // 获模块
          const processedIdentifier =
            trimmedIdentifier &&
            trimmedIdentifier[1].replace(/^@(\w+)[/\\]/, '$1-');

          return `${processedIdentifier || identifier}-lib`;
        },
        priority: 30,
        minChunks: 1,
        reuseExistingChunk: true,
        chunks: 'async',
      },
      shared: {
        name(_module: any, chunks: any) {
          // 生成唯一hash值
          const cryptoName = crypto
            .createHash('sha1')
            .update(
              chunks.reduce((acc: any, chunk: any) => {
                return acc + chunk.name;
              }, ''),
            )
            .digest('base64')
            // replace `+=/` that may be escaped in the url
            // https://github.com/umijs/umi/issues/9845
            .replace(/\//g, '')
            .replace(/\+/g, '-')
            .replace(/=/g, '_');
          return `shared-${cryptoName}`;
        },
        priority: 10,
        minChunks: 2,
        // 如果当前 chunk 包含已从主 bundle 中拆分出的模块，则它将被重用，而不是生成新的模块
        reuseExistingChunk: true,
        chunks: 'async',
      },
    },
  });
}
```
显然在并发有限的情况下，方案三是最佳的，我们分别采用这三种分包策略进行http请求首屏主页测试（low cpu， fast 3g 模式下）
`bigVendors`: 24 requests FP 5.30s LCP 15.31s
`depPerChunk`: 28 requests FP 4.47s LCP 14.70s
`granularChunks`: 23 requests FP 4.55s LCP 13.67s
```
codeSplitting: {
  jsStrategy: 'granularChunks',
},
```
结果还是使用 `granularChunks` 分包方案。

2. **逐个拆分**

6262 已经超出了500kb的警戒线，包括核身组建被分配在了2057下也比较占用资源我们可以把他单独拆分：
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701242876171-5af34f06-dcbc-4d1f-8152-587fa364256d.png#clientId=u50a3b8b2-ec81-4&from=paste&height=359&id=yvRRe&originHeight=1250&originWidth=1520&originalType=binary&ratio=2&rotation=0&showTitle=false&size=445430&status=done&style=none&taskId=udfe12078-2cdd-4029-a4ba-7131532d2b1&title=&width=436)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701242945749-defd7bb3-cf70-4ed2-bf65-7d40e223fc5d.png#clientId=u50a3b8b2-ec81-4&from=paste&height=290&id=BhtZW&originHeight=579&originWidth=550&originalType=binary&ratio=2&rotation=0&showTitle=false&size=62266&status=done&style=none&taskId=ub120f405-07f5-429b-8c3c-61e5989f12d&title=&width=275)
我们在umi的基础上加上我们对逐个包的拆分
> **注意：**
> 1. **priority 权重：必须为30，高权重可以从umi的分包策略中抢夺主动权**
> 2. **确定资源分布：一个资源可能在多个包内出现，不一定全部拆到一个包内，那如果我们拆分的资源在umi.js 内被调用就会出现**`**白屏**`**。**
> 3. **chunks:  属性可以设置 async异步资源、initial 同步资源、all全部 , 区分需要拆解的资源类型。**

![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701243767996-cf18d1eb-4d8f-4e2e-b0ab-175ccedef779.png#clientId=u50a3b8b2-ec81-4&from=paste&height=169&id=u8b7c9260&originHeight=337&originWidth=755&originalType=binary&ratio=2&rotation=0&showTitle=false&size=93233&status=done&style=none&taskId=ua4b20cd3-edd0-4d9f-9ef6-20bc4ea4ef6&title=&width=377.5)
```javascript
chainWebpack: function (memo) {
  memo.optimization.splitChunks({
    ...
    cacheGroups: {
      lodash: {
        test: /lodash/,
        priority: 30,
        chunks: 'async',
        name: 'lodash',
      },
      elliptic: {
        chunks: 'all',
        priority: 30,
        name: 'elliptic',
        test: /elliptic/,
      },
      bn: {
        chunks: 'all',
        priority: 30,
        name: 'bn.js',
        test: /bn.js/,
      },
      'readable-stream': {
        test: /readable-stream/,
        priority: 30,
        chunks: 'async',
        name: 'readable-stream',
      },
      'kernel-check': {
        test: /kernel-check/,
        priority: 30,
        chunks: 'async',
        name: 'kernel-check',
      },
      'crypto-js': {
        chunks: 'async',
        priority: 30,
        name: 'crypto-js',
        test: /crypto-js/,
      },
    },
  });
},
```
之后：
**8030 chunk从 500kb =>276kb**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701243929946-827edb2e-11a7-412b-94dc-3e2b527dbd45.png#clientId=u50a3b8b2-ec81-4&from=paste&height=256&id=u3795745a&originHeight=511&originWidth=724&originalType=binary&ratio=2&rotation=0&showTitle=false&size=113169&status=done&style=none&taskId=u0b7559c1-8417-4a7f-b390-a00bbdb3c2b&title=&width=362)
**核身和lodash被单独拆分：**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701243479347-5f2a7b2f-e587-45c6-80fc-964ab8ccebbc.png#clientId=u50a3b8b2-ec81-4&from=paste&height=200&id=u95171ce2&originHeight=400&originWidth=760&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67500&status=done&style=none&taskId=u4f826d7c-2f4d-45bc-867d-bcf8755de4b&title=&width=380)
**拆分umi.js: **
可以看到umi.js 是一个长任务，已经出现了红色警告，我们需要对umi.js 主文件进行优化：![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701245646791-0dcfd148-b72c-48b4-ba19-04502eb67a1e.png#clientId=u58774efd-bc26-4&from=paste&height=534&id=u83630721&originHeight=1068&originWidth=3580&originalType=binary&ratio=2&rotation=0&showTitle=false&size=912405&status=done&style=none&taskId=ua37d37e8-0f67-42ed-bf83-b44660833dc&title=&width=1790)
拆分umi.js 文件 i18n美杜莎资源和core-js
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701244504860-3b1d7c6a-a171-4655-9845-ca70cce73135.png#clientId=u50a3b8b2-ec81-4&from=paste&height=370&id=u68183d4e&originHeight=739&originWidth=723&originalType=binary&ratio=2&rotation=0&showTitle=false&size=126492&status=done&style=none&taskId=ubdc0efe0-309e-4519-9990-b5f7c3fe984&title=&width=361.5)
但是发现拆分后task长任务时间没有减少，整体页面性能也没有提升，主要和前置加载了很多的CDN文件，比如next组建库的文件本身体积较大，解析耗时较长。
umi拆分出这些静态资源在并发的上限内，对请求下载速度的影响不大，初始化时在FP之前的长任务可被容忍。

3. **diamond配置**

我们项目中配置了默认引入 mtop、react、react-dom等资源，但是mtop在我们的umi.js 内部已经存在，其本身内部资源大小和CDN引入资源相差不大，暂且先不拆分出来。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701251957919-0783bef2-decc-4d48-b344-62b29ecbb914.png#clientId=u07a6f84d-14ff-4&from=paste&height=150&id=uefcbda24&originHeight=300&originWidth=3376&originalType=binary&ratio=2&rotation=0&showTitle=false&size=278907&status=done&style=none&taskId=u7f63867d-c064-4cde-82c7-a422b78c6e9&title=&width=1688)
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701251178615-57e6b3dd-e742-498f-b21b-3c99b74c422a.png#clientId=u07a6f84d-14ff-4&from=paste&height=118&id=u15090a2f&originHeight=235&originWidth=734&originalType=binary&ratio=2&rotation=0&showTitle=false&size=24206&status=done&style=none&taskId=u50d4afeb-2788-47f4-8f33-3c2ef5cb7ce&title=&width=367)
那我们可以直接去掉mtop的cdn，然后用我们服务的资源合并地址语法 `??` 配合 `,` 分割 即可将react和react-dom两个资源合并到一个请求中去。
```javascript
// before
<script crossorigin src="$!{vendorAssetsHost}/code/lib/react/17.0.2/umd/react.production.min.js"></script>
<script crossorigin src="$!{vendorAssetsHost}/code/lib/react-dom/17.0.2/umd/react-dom.production.min.js"></script>

// after
<script crossorigin src="$!{vendorAssetsHost}/code/lib/??react/17.0.2/umd/react.production.min.js,react-dom/17.0.2/umd/react-dom.production.min.js"></script>
```
可以看到结果三个资源的请求时间变成了一个 `371ms`，且释放了两个请求并发资源。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701251826388-19495acb-27f0-4432-bb96-7e9e242f5903.png#clientId=u07a6f84d-14ff-4&from=paste&height=61&id=u7de07a19&originHeight=122&originWidth=3186&originalType=binary&ratio=2&rotation=0&showTitle=false&size=117120&status=done&style=none&taskId=u18cacea1-dde7-40ab-a24c-26b8ab2396a&title=&width=1593)

4. **React.lazy**

配合 **React.lazy** 将比较大的包动态引入，这会使打包工具将此文件相关依赖资源单独打成一个模块，并且在我们这个组建的逻辑加载到此句的时候才会** await import** 此模块，从而达到按需引入和分包的效果。
```javascript
import { lazy, Suspense } from 'react';
const LazyPageStepOne = lazy(() => import('./step1'));

export default function() {
  return (
    <Suspense fallback={<div>loading...</div}>
  		<LazyPageStepOne />
    </Suspense>
  )
}
```

5. **await import **

当然 **React.lazy **只能用于处理组建的按需引入，那如果出现一些比较重的方法改怎么办？比如我们代码内有一套比较重的加密算法，当我们进入到添加银行账户的时候，会同时请求11个接口
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701176966638-31ae1999-3560-4b8b-80f6-5ec98e56345a.png#clientId=u16ff8126-aec6-4&from=paste&height=270&id=eZuZ0&originHeight=539&originWidth=1500&originalType=binary&ratio=2&rotation=0&showTitle=false&size=188397&status=done&style=none&taskId=ub949d1f8-29f6-469a-89ba-0c066522742&title=&width=750)
但是部分资源都是在我们点击确定以后才会去引用，也就是加密相关的包，所以我们要使用await import 语法按需加载加密资源，只有用户点击下一步以后相关的加密js文件才进行加载：
```javascript
// before
const { body, key } = encryptForGooglePay(PUBLIC_KEY, JSON.stringify(payload));

// after
const encryptForGooglePay = (await import('@/vendors/alipay-password'))?.default;
const { body, key } = await encryptForGooglePay(PUBLIC_KEY, JSON.stringify(payload));
```
我们再次重复之前的操作初始化请求数量从`11个` => `6个`。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701177154746-d69b2c60-4a59-4bf4-ac03-998058dfdab8.png#clientId=u16ff8126-aec6-4&from=paste&height=123&id=MXQzT&originHeight=246&originWidth=1500&originalType=binary&ratio=2&rotation=0&showTitle=false&size=67096&status=done&style=none&taskId=u9174b053-0e5b-40a6-8f60-ddb28bb8565&title=&width=750)
### http2 和 gizp
**http版本：**
谷歌浏览器默认是不展示http版本在面板上的，有时我们可以在请求头上看到http版本，但是有时我们又看不到，首先我们需要打开请求的`protocol`选型,也就是
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700793492587-c58100d7-fd89-47eb-ad1c-ac5e291f50fc.png#clientId=ua985a20f-9bc5-4&from=paste&height=417&id=ue3431046&originHeight=1038&originWidth=1614&originalType=binary&ratio=2&rotation=0&showTitle=false&size=1259005&status=done&style=none&taskId=uc6f41d03-b34c-42c8-a781-3ca8543f022&title=&width=649)
就可以看到我们http协议的版本，我们的项目以及开启了。
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700793557513-1432d6ab-917c-44d0-b70c-c6ab777256fc.png#clientId=ua985a20f-9bc5-4&from=paste&height=150&id=u41c4de42&originHeight=300&originWidth=1790&originalType=binary&ratio=2&rotation=0&showTitle=false&size=117602&status=done&style=none&taskId=uce5d4a2f-9455-4c52-b044-5fb0f2caf84&title=&width=895)
**gizp：**
**从打包工具打包文件可以看出，我们的大包文件已经压缩，且在http请求头协议也可以看出已经开启了gizp。**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700793623940-eb56b01b-38a5-4055-8ef5-cde99ef420eb.png#clientId=ua985a20f-9bc5-4&from=paste&height=123&id=ue894699d&originHeight=245&originWidth=487&originalType=binary&ratio=2&rotation=0&showTitle=false&size=33302&status=done&style=none&taskId=u6d90c754-284b-4d7d-aa94-861e9e9c96a&title=&width=243.5)![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700793676554-8ca3f3ee-641e-44cb-8916-8ed191a237a7.png#clientId=ua985a20f-9bc5-4&from=paste&height=194&id=u9720caea&originHeight=387&originWidth=935&originalType=binary&ratio=2&rotation=0&showTitle=false&size=107559&status=done&style=none&taskId=u3c745683-7219-4171-a5cf-21f225a0e60&title=&width=467.5)

### 逻辑优化
**前置：**
逻辑的优化可以有效的提高等地时间，防止内存溢出，重复请求等，所以我们需要对自己的项目初始化逻辑仔细审查，发现有可以优化的地方。
**问题：**
我们项目默认初始化的时候是走串行逻辑：

- 判断是否入驻=> 是否新人指引 => 获取菜单=> 跳转首页

是因为为入驻需要跳转入驻页面，如果入驻了，但是没有新人指引，则进入新人指引页面，最后才是初始化菜单进入首页。
但是接口串行这会导致等待时间的增加和dom绘制的滞后。
所以我们将逻辑改成并且，在登陆后同时获取 入驻情况，新人指引情况，菜单配置，然后统一调度跳转页面。
优化前：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701747788348-acc7b7c6-14bd-4372-bdd3-462b08e95c10.jpeg)
优化后：
![](https://intranetproxy.alipay.com/skylark/lark/0/2023/jpeg/116956428/1701748102512-4775b7b6-309a-4d5a-9b36-4114f2103a46.jpeg)

**减少接口循环：**
在导出列表，接口为了获取当前表格最新的数据，以及导出完成情况，会一直不停的轮训列表接口，但是这样显然对后台服务是一个巨大的压力。
所以修改逻辑，当检测到当前页都完成了导出以后，就不会再轮训接口，需要用户手动进行刷新。

### 结果
**首页：**
正常网速

| **参数名称** | **优化前** | **优化后** |
| --- | --- | --- |
| DCL | 797.25ms  | 663.62ms |
| FP | 804.62ms | 728.94ms |
| FCP | 804.62ms | 728.94ms |
| L | 1.73s | 1.37s |
| LCP | **3.08s** | **2.05s** |

快速3g

| **参数名称** | **优化前** | **优化后** |
| --- | --- | --- |
| DCL | **10.35s** | 7.44s |
| FP | 4.48s | - |
| FCP | **19.04s** | 8.48s |
| L | 20.44s | 9.16s |
| LCP | 22.79s | 11.41s |

**正常网速：LCP 指标提升 **`**33.4%**`**。**
**快速3g：LCP 指标提升 **`**50%**`**。 **

**资源体积**
**优化前：								  优化后：**
![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1700739256787-62d2de2e-6f7c-4fd0-9f31-f37b4fc60e4a.png#clientId=u76628f32-d618-4&from=paste&height=184&id=u8eb96cc3&originHeight=682&originWidth=1340&originalType=binary&ratio=2&rotation=0&showTitle=false&size=501036&status=done&style=none&taskId=u4a99ee40-ff71-40d8-a8e6-d24f4847e6d&title=&width=362)  ![image.png](https://intranetproxy.alipay.com/skylark/lark/0/2023/png/116956428/1701175899332-faa65409-7f01-44e1-8f78-59149ad72a5f.png#clientId=u72f5e253-d967-4&from=paste&height=127&id=s7qHU&originHeight=277&originWidth=721&originalType=binary&ratio=2&rotation=0&showTitle=false&size=64455&status=done&style=none&taskId=ua90d46be-1b42-4253-8a12-ab4d0c7af90&title=&width=331.5)
压缩前总打包资源从 **3.0mb** => **2.26mb**, 体积缩小 `24.7%`。
首页资源体积从 **1934.1kb** => **1206kb**，体积缩小`**37.6%**`**。**

## 未来期望

- 接入用户行为轨迹监控。
- 保持0 ERROR问题现状。
- 抽离高复用组建开发公共组建，提高开发效率。
- 书写性能优化白皮书2023，汇总多手段优化方案。
- 保证商家钱包的功能完整、优异、精致、稳定。
- 接口报错是配AEM
- 控制台报错信息清楚或者过滤
## 参考资料
谷歌devTools task介绍 [https://web.dev/articles/optimize-long-tasks?utm_source=devtools&hl=zh-cn](https://web.dev/articles/optimize-long-tasks?utm_source=devtools&hl=zh-cn)
umi.js 官网 [https://umijs.org/docs/guides/directory-structure](https://umijs.org/docs/guides/directory-structure)
webpack官网 [https://webpack.js.org/](https://webpack.js.org/)
ATA-Umi 应用性能优化 [https://ata.atatech.org/articles/11000199256?spm=ata.23639746.0.0.740b3566yrjiXE](https://ata.atatech.org/articles/11000199256?spm=ata.23639746.0.0.740b3566yrjiXE)
ATA-物流中后台性能优化白皮书 [https://ata.atatech.org/articles/11020081259?spm=ata.23639746.0.0.1ae53c4fMaEQ7K#pOyveFbB](https://ata.atatech.org/articles/11020081259?spm=ata.23639746.0.0.1ae53c4fMaEQ7K#pOyveFbB)
掘金-时间分片技术（解决 js 长任务导致的页面卡顿）[https://juejin.cn/post/7008416027700789255](https://juejin.cn/post/7008416027700789255)
掘金-小册子-前端性能优化原理与实践 [https://juejin.cn/book/6844733750048210957?enter_from=course_center&utm_source=course_center](https://juejin.cn/book/6844733750048210957?enter_from=course_center&utm_source=course_center)
掘金-dns-prefetch 预解析技术-- 前端网络必知 [https://juejin.cn/post/7031815988031160328?searchId=202312061511548567DCAFB6A30E653C18](https://juejin.cn/post/7031815988031160328?searchId=202312061511548567DCAFB6A30E653C18)
掘金-前端必需了解的CDN知识 [https://juejin.cn/post/6913704568325046279?searchId=2023120616503980BF3378513E0B77ACD5](https://juejin.cn/post/6913704568325046279?searchId=2023120616503980BF3378513E0B77ACD5)
掘金-包体积瞬间缩小十五倍！拆包神技，一招搞定！ [https://juejin.cn/post/7296665348571791411?searchId=20231206173327C8592D69342696802D19](https://juejin.cn/post/7296665348571791411?searchId=20231206173327C8592D69342696802D19)
知乎-umi 项目如何做产物优化 [https://zhuanlan.zhihu.com/p/157540425?spm=ata.21736010.0.0.5be67536x4JpuA](https://zhuanlan.zhihu.com/p/157540425?spm=ata.21736010.0.0.5be67536x4JpuA)

